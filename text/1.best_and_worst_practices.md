> Плохие и хорошие практики тестирования

Тесты, как и любой другой код, можно писать по-разному, в том числе очень плохо.
Помимо каких-то общих практик и стандартов кодирования у тестов есть свои особенности,
о которых надо знать.


> Взаимное влияние тестов

Одно из ключевых правил: тесты не должны влиять друг на друга. Это значит, что 
любой тест выполняется так, как будто других тестов не существует в природе.

Нарушить это правило очень просто. Один тест может создать файл, изменить переменную
или записать что-то в базу. Если остальные тесты наткнутся на эти изменения, 
то они могут упасть там, где не должны падать, или наоборот — успешно пройти 
там, где не должны проходить. Кроме этого, в такой ситуации вводится 
неопределённость. Такие тесты могут падать эпизодически без видимых на то причин. 
Например, когда тест запускают изолированно, то он работает, а когда вместе с 
остальными — падает:

> Файл ./../files/tests/3/example.test.js

Особенно часто такая ситуация возникает в тестах, активно взаимодействующих с
внешней средой: базой данных или файловой системой.


> Условные конструкции в тесте
> Файл ./../files/tests/3/example2.test.js.txt

Любое ветвление внутри тестов это фактически несколько тестов в рамках одного теста.
От этого надо избавляться и никогда так не писать.


> Тест вне тестов
> Файл ./../files/tests/3/example3.test.js

В этом примере тестируемый код вызывается в beforeEach. Такой подход усложняет
анализ тестов, так как переворачивает всё с ног на голову.


> Слишком сильная детализация
> Файл ./../files/tests/3/example4.test.js

Программисты под влиянием голосов из интернета стремятся максимально разносить 
код по файлам, модулям и функциям. То же самое наблюдается и в тестах. 
Вместо одного теста, в котором содержатся все необходимые проверки, 
программист создаёт 5 тестов, в каждом из которых ровно одна проверка.

Чаще всего, единственным результатом такого разделения будет большее количество кода
и усложнение рефакторинга в будущем, когда кода станет по-настоящему много.


> Глубокая вложенность

Jest позволяет группировать тесты в блоки describe:
> Файл ./../files/tests/3/example5.test.js

Они помогают структурировать сложные тесты и задать для каждого блока describe
свой собственный beforeEach. Хотя такая возможность бывает полезна, но очень
легко начать использовать её во вред.

Глубокая иерархия тестов очень тяжело поддаётся анализу и фиксирует структуру.
Из-за этого возникают сложности при добавлении новых проверок. 
Становится непонятно, к чему она относится. Это проблема любых иерархий, 
которые рассматривают систему только с одной точки зрения.


> Код с тестами писать дольше, чем код без тестов

Это очень интересный вопрос, по которому можно понять, насколько хорошо программист
умеет писать тесты. Несмотря на то, что некоторые виды тестирования действительно 
сложны и требуют дополнительного времени, ежедневные тесты, которые пишутся вместе с
кодом, должны приводить к ускорению разработки. И на это есть пять причин:

- Тесты влияют на дизайн кода. Они помогают выявить неудачные решения намного раньше.
- Подготовка входных данных может занимать значительное время. С тестами это нужно сделать один раз.
- Проверка результата работы кода может быть сложной и разнообразной. Тесты позволяют об этом не думать, они сами проверяют, что всё хорошо, включая пограничные случаи.
- Если в проекте тесты пишутся регулярно, то проще и быстрее делать рефакторинг, так как не придётся проверять вручную другие части кода.
- Тесты снижают уровень стресса.

Доп: https://www.youtube.com/watch?v=zsz8kdi62mE